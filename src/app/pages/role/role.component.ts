// src/app/components/role/role.component.ts
import { Component, OnInit } from '@angular/core';
import { Role } from '../../models/role.model';
import { Permission } from '../../models/permission.model';
import { RoleService } from '../../services/role.service';
import { PermissionService } from '../../services/permission.service';

@Component({
  selector: 'app-role',
  templateUrl: './role.component.html',
  styleUrls: ['./role.component.css']
})
export class RoleComponent implements OnInit {
  roles: Role[] = [];
  permissions: Permission[] = [];
  selectedRole: Role | null = null;
  newRole: Role | null = null; // Used for adding/editing
  isEditing: boolean = false;
  showForm: boolean = false;

  constructor(
    private roleService: RoleService,
    private permissionService: PermissionService
  ) { }

  ngOnInit(): void {
    this.getRoles();
    this.getPermissions();
  }

  getRoles(): void {
    this.roleService.getRoles().then(
      (data: any) => {
        this.roles = data;
      },
      error => {
        console.error('Error fetching roles:', error);
      }
    );
  }

  getPermissions(): void {
    this.permissionService.getPermissions().subscribe(
      (data: Permission[]) => {
        this.permissions = data;
      },
      error => {
        console.error('Error fetching permissions:', error);
      }
    );
  }

  selectRole(role: Role): void {
    this.selectedRole = role;
    this.showForm = false;
    this.isEditing = false;
  }

  addRole(): void {
    this.newRole = {
      id_role: '', // Will be generated by backend
      name: '',
      permissions: [],
      created_at: new Date(),
      updated_at: new Date()
    };
    this.showForm = true;
    this.isEditing = false;
    this.selectedRole = null; // Clear selected role when adding
  }

  editRole(role: Role): void {
    // Create a deep copy to avoid modifying the original role directly
    this.newRole = { ...role, permissions: role.permissions ? [...role.permissions] : [] };
    this.showForm = true;
    this.isEditing = true;
    this.selectedRole = null; // Clear selected role when editing
  }

  async saveRole(): Promise<void> {
    if (this.newRole) {
      if (this.isEditing) {
        const observable = await this.roleService.putRole(this.newRole.id_role, this.newRole);
        if (observable) {
          observable.subscribe(
            (updatedRole: Role) => {
              const index = this.roles.findIndex(r => r.id_role === updatedRole.id_role);
              if (index > -1) {
                this.roles[index] = updatedRole;
              }
              this.cancel();
              M.toast({ html: 'Rol actualizado exitosamente!' });
            },
            error => {
              console.error('Error updating role:', error);
              M.toast({ html: 'Error al actualizar el rol.', classes: 'red' });
            }
          );
        }
      } else {
        this.newRole.created_at = new Date();
        this.newRole.updated_at = new Date();
        const observable = await this.roleService.postRole(this.newRole);
        if (observable) {
          observable.subscribe(
            (createdRole: Role) => {
              this.roles.push(createdRole);
              this.cancel();
              M.toast({ html: 'Rol creado exitosamente!' });
            },
            error => {
              console.error('Error creating role:', error);
              M.toast({ html: 'Error al crear el rol.', classes: 'red' });
            }
          );
        }
      }
    }
  }

  async deleteRole(id: string): Promise<void> {
    if (confirm('¿Estás seguro de que quieres eliminar este rol?')) {
      const observable = await this.roleService.deleteRole(id);
      if (observable) {
        observable.subscribe(
          () => {
            this.roles = this.roles.filter(r => r.id_role !== id);
            this.cancel();
            M.toast({ html: 'Rol eliminado exitosamente!' });
          },
          error => {
            console.error('Error deleting role:', error);
            M.toast({ html: 'Error al eliminar el rol.', classes: 'red' });
          }
        );
      }
    }
  }

  cancel(): void {
    this.selectedRole = null;
    this.newRole = null;
    this.showForm = false;
    this.isEditing = false;
  }

  // --- Permission handling for the form ---
  isPermissionAssigned(permissionId: string): boolean {
    if (!this.newRole || !this.newRole.permissions) {
      return false;
    }
    return this.newRole.permissions.some(p => p.id_permission === permissionId);
  }

  togglePermission(permission: Permission): void {
    if (!this.newRole) return;

    if (this.newRole.permissions) {
      const index = this.newRole.permissions.findIndex(p => p.id_permission === permission.id_permission);
      if (index > -1) {
        // Permission is already assigned, remove it
        this.newRole.permissions.splice(index, 1);
      } else {
        // Permission is not assigned, add it
        this.newRole.permissions.push(permission);
      }
    } else {
      // If permissions array is null/undefined, initialize and add
      this.newRole.permissions = [permission];
    }
  }
}