// src/app/components/role/role.component.ts
import { Component, OnInit } from '@angular/core';
import { Role } from '../../models/role.model';
import { Permission } from '../../models/permission.model';
import { RoleService } from '../../services/role.service';
import { PermissionService } from '../../services/permission.service';

@Component({
  selector: 'app-role',
  templateUrl: './role.component.html',
  styleUrls: ['./role.component.css']
})
export class RoleComponent implements OnInit {
  roles: Role[] = [];
  permissions: Permission[] = [];
  selectedRole: Role | null = null;
  newRole: Role | null = null; // Used for adding/editing
  isEditing: boolean = false;
  showForm: boolean = false;

  constructor(
    private roleService: RoleService,
    private permissionService: PermissionService
  ) { }

  ngOnInit(): void {
    this.getRoles();
    this.getPermissions();
  }

  getRoles(): void {
    this.roleService.getRoles().subscribe(
      (data: Role[]) => {
        console.log('Roles recibidos del backend:', data);
        this.roles = data;
      },
      error => {
        console.error('Error fetching roles:', error);
      }
    );
  }

  getPermissions(): void {
    this.permissionService.getPermissions().subscribe(
      (data: Permission[]) => {
        this.permissions = data;
      },
      error => {
        console.error('Error fetching permissions:', error);
      }
    );
  }

  selectRole(role: Role): void {
    this.selectedRole = role;
    this.showForm = false;
    this.isEditing = false;
  }

  addRole(): void {
    this.newRole = {
      id_role: '', // Will be generated by backend
      name: '',
      permissions: [],
      created_at: new Date(),
      updated_at: new Date()
    };
    this.showForm = true;
    this.isEditing = false;
    this.selectedRole = null; // Clear selected role when adding
  }

  editRole(role: Role): void {
    const observable = this.roleService.getRole(role.id_role);
    if (observable) {
      observable.subscribe((rolCompleto: any) => {
        const data = rolCompleto.data;
        const permisosArray = Array.isArray(data.permissions) ? data.permissions : [];
        const permisos = this.permissions.filter(p =>
          permisosArray.some((perm: any) => perm.id_permission === p.id_permission)
        );
        this.newRole = {
          id_role: data.id_role,
          name: data.name,
          permissions: permisos,
          created_at: data.created_at ? new Date(data.created_at) : new Date(),
          updated_at: data.updated_at ? new Date(data.updated_at) : new Date()
        };
        this.showForm = true;
        this.isEditing = true;
        this.selectedRole = null;
      });
    }
  }

  async saveRole(): Promise<void> {
    if (this.newRole) {
      if (this.isEditing) {
        const observable = await this.roleService.putRole(this.newRole.id_role, this.newRole);
        if (observable) {
          observable.subscribe(
            (updatedRole: Role) => {
              const index = this.roles.findIndex(r => r.id_role === updatedRole.id_role);
              if (index > -1) {
                this.roles[index] = updatedRole;
              }
              this.cancel();
              M.toast({ html: 'Rol actualizado exitosamente!' });
            },
            error => {
              console.error('Error updating role:', error);
              M.toast({ html: 'Error al actualizar el rol.', classes: 'red' });
            }
          );
        }
      } else {
        this.newRole.created_at = new Date();
        this.newRole.updated_at = new Date();
        const observable = await this.roleService.postRole(this.newRole);
        if (observable) {
          observable.subscribe(
            (createdRole: Role) => {
              this.roles.push(createdRole);
              this.cancel();
              M.toast({ html: 'Rol creado exitosamente!' });
            },
            error => {
              console.error('Error creating role:', error);
              M.toast({ html: 'Error al crear el rol.', classes: 'red' });
            }
          );
        }
      }
    }
  }

  async deleteRole(id: string): Promise<void> {
    if (confirm('¿Estás seguro de que quieres eliminar este rol?')) {
      const observable = await this.roleService.deleteRole(id);
      if (observable) {
        observable.subscribe(
          () => {
            this.roles = this.roles.filter(r => r.id_role !== id);
            this.cancel();
            M.toast({ html: 'Rol eliminado exitosamente!' });
          },
          error => {
            console.error('Error deleting role:', error);
            M.toast({ html: 'Error al eliminar el rol.', classes: 'red' });
          }
        );
      }
    }
  }

  cancel(): void {
    this.selectedRole = null;
    this.newRole = null;
    this.showForm = false;
    this.isEditing = false;
  }

  // --- Permission handling for the form ---
  isPermissionAssigned(permissionId: string): boolean {
    if (!this.newRole || !this.newRole.permissions) {
      return false;
    }
    // Permite comparar tanto si permissions es array de objetos como de strings
    return this.newRole.permissions.some((p: any) =>
      typeof p === 'string' ? p === permissionId : p.id_permission === permissionId
    );
  }

  togglePermission(permission: Permission): void {
    if (!this.newRole) return;

    if (this.newRole.permissions) {
      const index = this.newRole.permissions.findIndex((p: any) =>
        typeof p === 'string' ? p === permission.id_permission : p.id_permission === permission.id_permission
      );
      if (index > -1) {
        // Permission is already assigned, remove it
        this.newRole.permissions.splice(index, 1);
      } else {
        // Permission is not assigned, add it
        this.newRole.permissions.push(permission);
      }
    } else {
      // If permissions array is null/undefined, initialize and add
      this.newRole.permissions = [permission];
    }
  }
}