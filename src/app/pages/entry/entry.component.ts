// src/app/entry/entry.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Product } from '../../models/product.model';
import { Category } from '../../models/category.model';
import { Provider } from '../../models/provider.model';
import { Subcategory } from '../../models/subcategory.model';
import { ProductService } from '../../services/product.service';
import { CategoryService } from '../../services/category.service';
import { ProviderService } from '../../services/provider.service';
import { SubcategoryService } from '../../services/subcategory.service';

declare var $: any; // Declare $ for Materialize CSS
declare var M: any; // Declare M for Materialize global object

@Component({
  selector: 'app-entry',
  templateUrl: './entry.component.html',
  styleUrls: ['./entry.component.css']
})
export class EntryComponent implements OnInit {
  entryForm: FormGroup;
  categories: Category[] = [];
  providers: Provider[] = [];
  subcategories: Subcategory[] = [];

  constructor(
    private fb: FormBuilder,
    private productService: ProductService,
    private categoryService: CategoryService,
    private providerService: ProviderService,
    private subcategoryService: SubcategoryService
  ) {
    this.entryForm = this.fb.group({
      name: ['', Validators.required],
      code: ['', Validators.required], // Código de barras
      invoice_number: ['', Validators.required], // Orden de donacion
      id_provider: ['', Validators.required],
      expiration_date: ['', Validators.required],
      id_category: ['', Validators.required],
      id_subcategory: ['', Validators.required],
      lot: ['', Validators.required],
      unit: [0, [Validators.required, Validators.min(0)]], // Unidad
      quantity: [0, [Validators.required, Validators.min(1)]],
      total_weight: ['', Validators.required], // Peso Total
      entry_date: ['', Validators.required], // Added for completeness, usually current date
      received_by: ['', Validators.required],
      headquarters: ['', Validators.required],
      place_in_inventory: ['', Validators.required],
      id_state_product: [''],
      unit_weight: ['', Validators.required],
      // id_product is typically generated by backend or not needed for creation
    });
  }

  ngOnInit(): void {
    this.loadCategories();
    this.loadProviders();
    this.loadSubcategories();

    $(document).ready(() => {
      // Inicializar selects
      $('select').formSelect();
      
      // Establecer fecha actual por defecto para entry_date
      const today = new Date();
      const formattedToday = today.toISOString().split('T')[0];
      this.entryForm.patchValue({ entry_date: formattedToday });
    });
  }

  loadCategories(): void {
    this.categoryService.getCategorys().subscribe(
      (data: Category[]) => {
        console.log('Categorías cargadas:', data);
        this.categories = data;
        this.initializeSelects();
      },
      (error) => {
        console.error('Error loading categories:', error);
        M.toast({ html: 'Error al cargar categorías.' });
      }
    );
  }

  loadProviders(): void {
    this.providerService.getProviders().subscribe(
      (data: Provider[]) => {
        console.log('Proveedores cargados:', data);
        this.providers = data;
        this.initializeSelects();
      },
      (error) => {
        console.error('Error loading providers:', error);
        M.toast({ html: 'Error al cargar proveedores.' });
      }
    );
  }

  loadSubcategories(): void {
    this.subcategoryService.getSubcategorys().subscribe(
      (data: Subcategory[]) => {
        console.log('Subcategorías cargadas:', data);
        this.subcategories = data;
        this.initializeSelects();
      },
      (error) => {
        console.error('Error loading subcategories:', error);
        M.toast({ html: 'Error al cargar subcategorías.' });
      }
    );
  }

  private initializeSelects(): void {
    setTimeout(() => {
      const elems = document.querySelectorAll('select');
      M.FormSelect.init(elems);
    }, 100);
  }

  onSubmit(): void {
    if (this.entryForm.invalid) {
      M.toast({ html: 'Por favor, complete todos los campos requeridos.' });
      this.entryForm.markAllAsTouched(); // Show validation errors
      return;
    }

    const formData = this.entryForm.value;
    
    // Asegurarse de que las fechas estén en el formato correcto
    const newProduct: Product = {
      ...formData,
      expiration_date: formData.expiration_date,
      entry_date: formData.entry_date,
      id_product: 'auto-generated-' + Date.now(), // Placeholder, backend should generate
    };
    delete newProduct.id_state_product
    this.productService.postProduct(newProduct).subscribe(
      (response) => {
        M.toast({ html: 'Producto ingresado exitosamente!' });
        this.entryForm.reset();
        // Manually reset selects for Materialize
        this.entryForm.controls['id_category'].setValue('');
        this.entryForm.controls['id_provider'].setValue('');
        this.entryForm.controls['id_subcategory'].setValue('');
        setTimeout(() => $('select').formSelect(), 0);
        // Re-set default entry date
        const today = new Date();
        const formattedToday = today.toISOString().split('T')[0];
        this.entryForm.controls['entry_date'].setValue(formattedToday);
        M.updateTextFields(); // Update Materialize labels
      },
      (error) => {
        M.toast({ html: 'Error al ingresar el producto.' });
        console.error('Error entering product:', error);
      }
    );
  }

  // Helper methods for displaying names in dropdowns (optional, but good for context)
  getCategoryName(id: string): string {
    const category = this.categories.find(c => c.id_category === id);
    return category ? category.name : '';
  }

  getProviderName(id: string): string {
    const provider = this.providers.find(p => p.id_providers === id);
    return provider ? provider.legal_name : '';
  }

  getSubcategoryName(id: string): string {
    const subcategory = this.subcategories.find(s => s.id_subcategory === id);
    return subcategory ? subcategory.name : '';
  }
}